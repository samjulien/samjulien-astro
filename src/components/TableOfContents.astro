---
interface Heading {
  depth: number;
  slug: string;
  text: string;
}

interface Props {
  headings: Heading[];
  minHeadings?: number;
}

const { headings, minHeadings = 3 } = Astro.props;

// Filter to only h2 and h3
const filteredHeadings = headings.filter(h => h.depth >= 2 && h.depth <= 3);

// Don't render if not enough headings
const shouldRender = filteredHeadings.length >= minHeadings;
---

{shouldRender && (
  <nav class="toc-container lg:h-full" aria-label="Table of contents">
    <!-- Mobile: Collapsible -->
    <details class="lg:hidden mb-6 bg-gray-50 dark:bg-gray-800 rounded-lg">
      <summary class="cursor-pointer p-4 font-semibold text-gray-900 dark:text-gray-100 flex items-center gap-2">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h7" />
        </svg>
        Table of Contents
      </summary>
      <ul class="p-4 pt-0 space-y-2">
        {filteredHeadings.map(heading => (
          <li class={heading.depth === 3 ? 'ml-4' : ''}>
            <a
              href={`#${heading.slug}`}
              class="text-gray-600 dark:text-gray-400 hover:text-green-600 dark:hover:text-green-400 transition-colors block py-1"
            >
              {heading.text}
            </a>
          </li>
        ))}
      </ul>
    </details>

    <!-- Desktop: Sticky sidebar -->
    <div class="hidden lg:block lg:h-full">
      <div class="sticky top-8">
        <h2 class="text-sm font-semibold text-gray-900 dark:text-gray-100 uppercase tracking-wide mb-4">
          On this page
        </h2>
        <ul class="space-y-2 text-sm border-l-2 border-gray-200 dark:border-gray-700">
          {filteredHeadings.map(heading => (
            <li class={heading.depth === 3 ? 'ml-2' : ''}>
              <a
                href={`#${heading.slug}`}
                class="toc-link block py-1 pl-4 -ml-px border-l-2 border-transparent text-gray-600 dark:text-gray-400 hover:text-green-600 dark:hover:text-green-400 hover:border-green-500 transition-colors"
                data-heading={heading.slug}
              >
                {heading.text}
              </a>
            </li>
          ))}
        </ul>
      </div>
    </div>
  </nav>
)}

<script is:inline>
  // Highlight current section in TOC based on scroll position
  // Only run once, guard against multiple executions
  if (!window.__tocInitialized) {
    window.__tocInitialized = true;

    // Wait for DOM to be fully ready
    function initTOC() {
      var tocLinks = document.querySelectorAll('.toc-link');
      if (tocLinks.length === 0) return;

      // Build pairs of {link, heading} using the link's href to find headings
      var pairs = [];
      for (var i = 0; i < tocLinks.length; i++) {
        var link = tocLinks[i];
        var href = link.getAttribute('href');
        if (href && href.startsWith('#')) {
          var id = href.substring(1);
          var heading = document.getElementById(id);
          if (heading) {
            pairs.push({ link: link, heading: heading });
          }
        }
      }

      if (pairs.length === 0) return;

      var currentActive = null;

      function setActiveLink(link) {
        if (currentActive) {
          currentActive.classList.remove('border-green-500', 'text-green-600', 'dark:text-green-400');
          currentActive.classList.add('border-transparent', 'text-gray-600', 'dark:text-gray-400');
        }
        currentActive = link;
        if (link) {
          link.classList.remove('border-transparent', 'text-gray-600', 'dark:text-gray-400');
          link.classList.add('border-green-500', 'text-green-600', 'dark:text-green-400');
        }
      }

      function updateActiveHeading() {
        var scrollY = window.scrollY;
        var offset = 120;
        var activeLink = null;

        for (var i = 0; i < pairs.length; i++) {
          var heading = pairs[i].heading;
          var top = heading.getBoundingClientRect().top;
          if (top <= offset) {
            activeLink = pairs[i].link;
          }
        }

        setActiveLink(activeLink);
      }

      // Throttled scroll handler
      var ticking = false;
      window.addEventListener('scroll', function() {
        if (!ticking) {
          requestAnimationFrame(function() {
            updateActiveHeading();
            ticking = false;
          });
          ticking = true;
        }
      }, { passive: true });

      // Initial update
      updateActiveHeading();
    }

    // Run after a short delay to ensure content is rendered
    if (document.readyState === 'complete') {
      setTimeout(initTOC, 50);
    } else {
      window.addEventListener('load', function() {
        setTimeout(initTOC, 50);
      });
    }
  }
</script>
