---
interface Heading {
  depth: number;
  slug: string;
  text: string;
}

interface Props {
  headings: Heading[];
  minHeadings?: number;
}

const { headings, minHeadings = 3 } = Astro.props;

// Filter to only h2 and h3
const filteredHeadings = headings.filter(h => h.depth >= 2 && h.depth <= 3);

// Don't render if not enough headings
const shouldRender = filteredHeadings.length >= minHeadings;
---

{shouldRender && (
  <nav class="toc-container lg:h-full" aria-label="Table of contents">
    <!-- Mobile: Collapsible -->
    <details class="lg:hidden mb-6 bg-gray-50 dark:bg-gray-800 rounded-lg">
      <summary class="cursor-pointer p-4 font-semibold text-gray-900 dark:text-gray-100 flex items-center gap-2">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h7" />
        </svg>
        Table of Contents
      </summary>
      <ul class="p-4 pt-0 space-y-2">
        {filteredHeadings.map(heading => (
          <li class={heading.depth === 3 ? 'ml-4' : ''}>
            <a
              href={`#${heading.slug}`}
              class="text-gray-600 dark:text-gray-400 hover:text-green-600 dark:hover:text-green-400 transition-colors block py-1"
            >
              {heading.text}
            </a>
          </li>
        ))}
      </ul>
    </details>

    <!-- Desktop: Sticky sidebar -->
    <div class="hidden lg:block lg:h-full">
      <div class="sticky top-8">
        <h2 class="text-sm font-semibold text-gray-900 dark:text-gray-100 uppercase tracking-wide mb-4">
          On this page
        </h2>
        <ul class="space-y-2 text-sm border-l-2 border-gray-200 dark:border-gray-700">
          {filteredHeadings.map(heading => (
            <li class={heading.depth === 3 ? 'ml-2' : ''}>
              <a
                href={`#${heading.slug}`}
                class="toc-link block py-1 pl-4 -ml-px border-l-2 border-transparent text-gray-600 dark:text-gray-400 hover:text-green-600 dark:hover:text-green-400 hover:border-green-500 transition-colors"
                data-heading={heading.slug}
              >
                {heading.text}
              </a>
            </li>
          ))}
        </ul>
      </div>
    </div>
  </nav>
)}

<script>
  // Highlight current section in TOC based on scroll position
  document.addEventListener('DOMContentLoaded', () => {
    const tocLinks = document.querySelectorAll('.toc-link');
    if (tocLinks.length === 0) return;

    const headingSlugs = Array.from(tocLinks).map(link =>
      link.getAttribute('data-heading')
    ).filter(Boolean) as string[];

    const headingElements = headingSlugs
      .map(slug => document.getElementById(slug))
      .filter(Boolean) as HTMLElement[];

    if (headingElements.length === 0) return;

    let currentActive: Element | null = null;

    function setActiveLink(slug: string | null) {
      // Remove active class from previous
      if (currentActive) {
        currentActive.classList.remove('border-green-500', 'text-green-600', 'dark:text-green-400');
        currentActive.classList.add('border-transparent', 'text-gray-600', 'dark:text-gray-400');
      }

      if (!slug) {
        currentActive = null;
        return;
      }

      // Add active class to current
      const activeLink = document.querySelector(`.toc-link[data-heading="${slug}"]`);
      if (activeLink) {
        activeLink.classList.remove('border-transparent', 'text-gray-600', 'dark:text-gray-400');
        activeLink.classList.add('border-green-500', 'text-green-600', 'dark:text-green-400');
        currentActive = activeLink;
      }
    }

    function updateActiveHeading() {
      const scrollY = window.scrollY;
      const offset = 100; // Offset from top of viewport

      // Find the last heading that's been scrolled past
      let activeSlug: string | null = null;
      for (const heading of headingElements) {
        const top = heading.getBoundingClientRect().top + window.scrollY;
        if (top <= scrollY + offset) {
          activeSlug = heading.id;
        } else {
          break;
        }
      }

      setActiveLink(activeSlug);
    }

    // Update on scroll with throttling
    let ticking = false;
    window.addEventListener('scroll', () => {
      if (!ticking) {
        requestAnimationFrame(() => {
          updateActiveHeading();
          ticking = false;
        });
        ticking = true;
      }
    });

    // Initial update
    updateActiveHeading();
  });
</script>
